from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from hashlib import sha256
from Crypto.Util.number import long_to_bytes, inverse
from math import gcd

p = 10699940648196411028170713430726559470427113689721202803392638457920771439452897032229838317321639599506283870585924807089941510579727013041135771337631951
q = 11956676387836512151480744979869173960415735990945471431153245263360714040288733895951317727355037104240049869019766679351362643879028085294045007143623763
n = p * q

# Public Keys
vka   = 124641741967121300068241280971408306625050636261192655845274494695382484894973990899018981438824398885984003880665335336872849819983045790478166909381968949910717906136475842568208640203811766079825364974168541198988879036997489130022151352858776555178444457677074095521488219905950926757695656018450299948207
vkakb = 114778245184091677576134046724609868204771151111446457870524843414356897479473739627212552495413311985409829523700919603502616667323311977056345059189257932050632105761365449853358722065048852091755612586569454771946427631498462394616623706064561443106503673008210435922340001958432623802886222040403262923652
vkb   = 6568897840127713147382345832798645667110237168011335640630440006583923102503659273104899584827637961921428677335180620421654712000512310008036693022785945317428066257236409339677041133038317088022368203160674699948914222030034711433252914821805540365972835274052062305301998463475108156010447054013166491083
c     = bytes.fromhex('fef29e5ff72f28160027959474fc462e2a9e0b2d84b1508f7bd0e270bc98fac942e1402aa12db6e6a36fb380e7b53323')

# The vulnerability: v = p * (random number) mod n
# This means v is always a multiple of p, so v mod p = 0
# The entire key exchange just multiplies/divides by k_A and k_B,
# so the final shared secret v_s is also a multiple of p → v_s mod p = 0

# We work mod q to find the other half of v_s.
# From the protocol: vkakb = vka * k_B mod n
# So mod q: k_B ≡ vkakb * vka⁻¹ (mod q)
k_B_q = (vkakb % q) * inverse(vka % q, q) % q

# Now recover v_s mod q using: v_s = vkb * k_B⁻¹ mod q
v_s_q = (vkb % q) * inverse(k_B_q, q) % q

# Use CRT to combine v_s mod p = 0 and v_s mod q to get v_s mod n
# CRT: v_s = 0*(q*q^-1 mod p) + v_s_q*(p*p^-1 mod q) mod n
v_s = (v_s_q * p % n) * inverse(p, q) % n

# Derive the AES key the same way Alice did: SHA256 of the shared secret
key = sha256(long_to_bytes(v_s)).digest()

cipher = AES.new(key, AES.MODE_ECB)
flag = unpad(cipher.decrypt(c), 16)
print(flag)
